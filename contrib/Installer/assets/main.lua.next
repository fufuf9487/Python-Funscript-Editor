json = require "json"

-- global var
processHandleMTFG = nil
processHandleConfigDir = nil
processHandleLogFile = nil
logfileExist = false
updateCounter = 0
scriptIdx = 1
mtfgVersion = "0.0.0"
status = "MTFG not running"
multiaxis = false
tmpFileName = "funscript_actions.json"
tmpFileExists = false
scriptNames = {}
scriptAssignment = {x={idx=1}, y={idx=1}, roll={idx=1}}

function exists(file)
   return os.rename(file, file)
end

function get_platform()
    if ofs.ExtensionDir():find("^/home/") ~= nil then
        local home = os.getenv( "HOME" )
        print("User Home: ", home)
        if exists(home.."/miniconda3/envs/funscript-editor") then
            return "Linux, Conda"
        elseif exists(home.."/anaconda3/envs/funscript-editor") then
            return "Linux, Conda"
        else
            return "Linux, Python"
        end
    else
        return "Windows"
    end
end

platform = get_platform()

function start_funscript_generator()
    if processHandleMTFG then
        print('MTFG already running')
        return
    end

    scriptIdx = ofs.ActiveIdx()
    local tmpFile = ofs.ExtensionDir() .. "/" .. tmpFileName
    local video = player.CurrentVideo()
    local script = ofs.Script(scriptIdx)
    local currentTimeMs = player.CurrentTime() * 1000

    print("tmpFile: ", tmpFile)
    print("video: ", video)
    print("currentScriptIdx: ", scriptIdx)
    print("currentTimeMs: ", currentTimeMs)

    local next_action = ofs.ClosestActionAfter(script, currentTimeMs / 1000)
    if next_action and script.actions[next_action].at < (currentTimeMs + 500) then
        next_action = ofs.ClosestActionAfter(script, script.actions[next_action].at / 1000)
    end

    print("nextAction: ", next_action and tostring(script.actions[next_action].at) or "nil")

    local cmd = ""
    local args = {}

    if platform == "Windows" then
        cmd = ofs.ExtensionDir() .. "/funscript-editor/funscript-editor.exe"
    elseif platform == "Linux, Python" then
        cmd = "/usr/bin/python3"
        table.insert(args, ofs.ExtensionDir() .. "/Python-Funscript-Editor/funscript-editor.py")
    elseif platform == "Linux, Conda" then
        cmd = "/usr/bin/bash"
        table.insert(args, ofs.ExtensionDir() .. "/Python-Funscript-Editor/conda_wrapper.sh")
    else
        print("ERROR: Platform Not Implemented (", platform, ")")
    end

    table.insert(args, "--generator")

    if multiaxis then;
        table.insert(args, "--multiaxis")
    end

    table.insert(args, "-s")
    table.insert(args, tostring(currentTimeMs))
    table.insert(args, "-i")
    table.insert(args, video)
    table.insert(args, "-o")
    table.insert(args, tmpFile)

    if next_action then
        table.insert(args, "-e")
        table.insert(args, tostring(script.actions[next_action].at))
    end

    print("cmd: ", cmd)
    print("args: ", table.unpack(args))

    processHandleMTFG = ofs.CreateProcess(cmd, table.unpack(args))

    status = "MTFG running"
end


function import_funscript_generator_csv_result()
    status = "MTFG not running"
    local tmpFile = ofs.ExtensionDir() .. "/" .. tmpFileName
    local f = io.open(tmpFile)
    if not f then
        print('Funscript Generator csv output file not found')
        return
    end

    script = ofs.Script(scriptIdx)
    local k = 1
    for line in f:lines() do
        -- first line is header
        if k > 1 then
            for at, pos in string.gmatch(line, "(%w+);(%w+)") do
                ofs.AddAction(script, at, pos, true)
            end
        end
        k = k + 1
    end
    f:close()

    -- save changes
    ofs.Commit(script)

    -- delete csv file
    os.remove(tmpFile)
end

function import_funscript_generator_json_result()
    status = "MTFG not running"
    local tmpFile = ofs.ExtensionDir() .. "/" .. tmpFileName
    local f = io.open(tmpFile)
    if not f then
        print('Funscript Generator json output file not found')
        return
    end

    local content = f:read("*a")
    f:close()
    json_body = json.decode(content)
    actions = json_body["actions"]

    if multiaxis then
        local i = 1
        while ofs.Script(i) do
            name = ofs.ScriptTitle(i)
            for k,v in pairs(scriptAssignment) do
                if name and name == scriptNames[v.idx] then
                    if actions[k] then
                        script = ofs.Script(i)
                        for _, action in pairs(actions[k]) do
                            ofs.AddAction(script, action["at"], action["pos"], true)
                        end
                        ofs.Commit(script)
                    end
                end
            end
       	    i = i + 1
        end
    else
        script = ofs.Script(scriptIdx)

        for metric, actions_metric in pairs(actions) do
            print('add ', metric, ' to ', ofs.ScriptTitle(scriptIdx))
            for _, action in pairs(actions_metric) do
                ofs.AddAction(script, action["at"], action["pos"], true)
            end
        end

        -- save changes
        ofs.Commit(script)
    end

    -- delete json file
    -- os.remove(tmpFile)
end


function invert_selected()
    local script = ofs.Script(ofs.ActiveIdx())
    for idx, action in ipairs(script.actions) do
        if action.selected then
            action.pos = clamp(100 - action.pos, 0, 100)
        end
    end
    ofs.Commit(script)
end


function align_bottom_points(align_value)
    local script = ofs.Script(ofs.ActiveIdx())

    -- get min value in selection if no align_value was given
    if align_value < 0 then
        align_value = 99
        for idx, action in ipairs(script.actions) do
            if action.selected then
                if action.pos < align_value then
                    align_value = action.pos
                end
            end
        end
    end

    -- align bottom points
    for idx, action in ipairs(script.actions) do
        if action.selected then
            local bottom_point = true

            local next_action = ofs.ClosestActionAfter(script, action.at / 1000)
            if next_action then
                if script.actions[next_action].pos <= action.pos then
                    bottom_point = false
                end
            end

            local prev_action = ofs.ClosestActionBefore(script, action.at / 1000)
            if prev_action then
                if script.actions[prev_action].pos <= action.pos then
                    bottom_point = false
                end
            end

            if bottom_point then
                action.pos = align_value
            end
        end
    end

    ofs.Commit(script)
end


function align_top_points(align_value)
    local script = ofs.Script(ofs.ActiveIdx())

    -- get max value in selection if no align_value was given
    if align_value < 0 then
        align_value = 1
        for idx, action in ipairs(script.actions) do
            if action.selected then
                if action.pos > align_value then
                    align_value = action.pos
                end
            end
        end
    end

    -- align top points
    for idx, action in ipairs(script.actions) do
        if action.selected then
            local top_point = true

            local next_action = ofs.ClosestActionAfter(script, action.at / 1000)
            if next_action then
                if script.actions[next_action].pos >= action.pos then
                    top_point = false
                end
            end

            local prev_action = ofs.ClosestActionBefore(script, action.at / 1000)
            if prev_action then
                if script.actions[prev_action].pos >= action.pos then
                    top_point = false
                end
            end

            if top_point then
                action.pos = align_value
            end
        end
    end

    ofs.Commit(script)
end


function init()
    print("Detected OS: ", platform)
    ofs.Bind("start_funscript_generator", "execute the funcript generator")
    local version_file_path = ""
    if platform == "Windows" then
        version_file_path = ofs.ExtensionDir().."\\funscript-editor\\funscript_editor\\VERSION.txt"
    else
        local mtfg_repo_path = ofs.ExtensionDir().."/Python-Funscript-Editor"
        local cmd = "git -C "..mtfg_repo_path.." describe --tags `git -C "..mtfg_repo_path.." rev-list --tags --max-count=1` > "..mtfg_repo_path.."/funscript_editor/VERSION.txt"
        -- print("cmd: ", cmd)
        os.execute(cmd)
        version_file_path = mtfg_repo_path.."/funscript_editor/VERSION.txt"
    end
    local f = io.open(version_file_path)
    if f then
        for line in f:lines() do
            if string.find(string.lower(line), "v") then
                mtfgVersion = string.lower(line):gsub("v", "")
            end
        end
        f:close()
    end
end

function update_logfile_exists()
        local logfile = ""
        if platform == "Windows" then
            logfile = "C:/Temp/funscript_editor.log"
        else
            logfile = "/tmp/funscript_editor.log"
        end
        local f = io.open(logfile)
        if f then
            logfileExist = true
            f:close()
        else
            logfileExist = false
        end
end


function is_empty(s)
  return s == nil or s == ''
end


function update_script_names()
    local i = 1
    scriptNames = {'ignore'}
    while ofs.Script(i) do
       name = ofs.ScriptTitle(i)
       if not is_empty(name) then
           table.insert(scriptNames, name)
       end
       i = i + 1
    end
end

function update_tmp_file_exists()
    local tmpFile = ofs.ExtensionDir() .. "/" .. tmpFileName
    local f = io.open(tmpFile)
    if f then
        tmpFileExists = true
        f:close()
    else
        tmpFileExists = false
    end
end


function update(delta)
    updateCounter = updateCounter + 1
    if processHandleMTFG and not ofs.IsProcessAlive(processHandleMTFG) then
        print('funscript generator completed import result')
        processHandleMTFG = nil
        import_funscript_generator_json_result()
    end
    if math.fmod(updateCounter, 100) == 1 then
        update_logfile_exists()
        update_script_names()
        update_tmp_file_exists()
    end
end


function gui()
    ofs.Text("Status: "..status)
    ofs.Text("Version: "..mtfgVersion)
    ofs.Text("Action:")

    ofs.SameLine()
    if not processHandleMTFG then

        if ofs.Button("Start MTFG") then
            start_funscript_generator()
        end
    else
        if ofs.Button("Kill MTFG") then
            if platform == "Windows" then
                os.execute("taskkill /f /im funscript-editor.exe")
            else
                os.execute("pkill -f funscript-editor.py")
            end
        end
    end

    ofs.SameLine()
    if ofs.Button("Open Config") then
        if platform == "Windows" then
            processHandleConfigDir = ofs.CreateProcess("explorer.exe", ofs.ExtensionDir().."\\funscript-editor\\funscript_editor\\config")
        else
            local cmd = '/usr/bin/dbus-send --session --print-reply --dest=org.freedesktop.FileManager1 --type=method_call /org/freedesktop/FileManager1 org.freedesktop.FileManager1.ShowItems array:string:"file://'
                ..ofs.ExtensionDir()..'/Python-Funscript-Editor/funscript_editor/config/" string:""'
            -- print("cmd: ", cmd)
            os.execute(cmd)
        end
    end

    if logfileExist then
        if platform == "Windows" then
            ofs.SameLine()
            if ofs.Button("Open Log") then
                 processHandleLogFile = ofs.CreateProcess("notepad.exe", "C:/Temp/funscript_editor.log")
            end
        else
            ofs.SameLine()
            if ofs.Button("Open Log") then
                processHandleLogFile = ofs.CreateProcess("/usr/bin/xdg-open", "/tmp/funscript_editor.log")
            end
        end
    end

    if tmpFileExists then
        ofs.SameLine()
        if ofs.Button("Force Import") then
            scriptIdx = ofs.ActiveIdx()
            import_funscript_generator_json_result()
        end
    end

    ofs.Separator()

    multiaxis, valueChanged = ofs.Checkbox("multiaxis", multiaxis)

    if multiaxis then
        local comboNum = 1
        for k,v in pairs(scriptAssignment) do
              ofs.Text(k.." => ")
              ofs.SameLine()
              v.idx, _ = ofs.Combo("#"..tostring(comboNum), v.idx, scriptNames)
              comboNum = comboNum + 1
        end
    end

    ofs.Separator()

    ofs.Text("Post-Processing:")
    ofs.SameLine()
    if ofs.Button("Invert") then
        invert_selected()
    end

    ofs.SameLine()
    if ofs.Button("Align Bottom Points") then
        align_bottom_points(-1)
    end

    ofs.SameLine()
    if ofs.Button("Align Top Points") then
        align_top_points(-1)
    end

end
